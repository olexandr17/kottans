Git branching
http://pcottle.github.io/learnGitBranching/

Добро пожаловать в LearnGitBranching!
Это приложение создано, чтобы помочь новичкам постичь мощные возможности ветвления и работы с git. Мы надеемся, что вам понравится эта игра и может вы что-то усвоите!
Демо!
Если ты не видел демонстрацию – посмотри её тут:
http://pcottle.github.io/learnGitBranching/?demo
Достало это сообщение? Добавь ?NODEMO к адресу и навсегда забудь о нём, ниже ссылка для удобства:
http://pcottle.github.io/learnGitBranching/?NODEMO

Команды Git
В нашей песочнице можно использовать множество команд:
    commit
    branch
    checkout
    cherry-pick
    reset
    revert
    rebase
    merge

Бог велел – делись!
Ты можешь делиться результатами с друзьями при помощи export tree и import tree
Хочешь создать классный уровень? Сделай это при помощи build level или добавь уровень друга при помощи import level
Команда show commands покажет все доступные инструкции. Там есть очень полезные, например undo и reset
А пока просто начни игру при помощи levels...


1.1. Коммиты в GIT
Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше
Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию какждый раз, а ужимает (когда это возможно) коммит в набор изменений или "дельту" между текущей версией и предыдущей.
Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков -- мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!
Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!
commit 'comment'

1.2. Ветвление в Git
Ветки в Git как и коммиты невероятно легковесны. Это просто ссылки на определённый коммит -- ничего более. Вот почему многие фанаты Git повторяют мантру
делай ветки сразу, делай ветки часто
Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.
Чуть позже мы попробуем использовать ветки и коммиты и вы увидите как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущих коммитов и всех его родителей.
branch <branch_name>
checkout <branch_name>

1.3. Ветки и слияния
Ок! Теперь мы знаем как создавать ветки и коммитить наши изменения. Теперь надо понять как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.
Первый способ объединения изменений, который мы рассмотрим - это git merge - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита, с другим коммитом и всеми их родителскими коммитами.
Слишком запутанно =) На схеме всё проще и понятнее.
merge <branch_name>
branch -d <branch_name>

1.4. Git Rebase
Второй способ объединения изменений в ветках - это rebasing. При ребэйзе Git по сути копирует набор коммитов и переносит их в другое место.
Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что при его помощи можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.
rebase <branch_name>


Прогулка по Git
Прежде, чем перейти к более продвинутым фичам Git, важно понять различные способы перемещения по дереву коммитов вашего проекта.
Как только вы научитесь свободно передвигаться по дереву коммитов, ваши возможности в Git преумножатся.

2.1. HEAD
В первую очередь, поговорим о "HEAD". HEAD - это символическое имя текущего выбранного коммита -- это, по сути, тот коммит, над которым мы в данным момент работаем.
HEAD всегда указывает на последний коммит, из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.
Обычно HEAD указывает на имя ветки (например bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.
checkout <commit_name>

2.2. Относительные ссылки
Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать git log, чтобы найти хеш нужного коммита
Более того, хеши в реальном репозитории Git сильно более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - fed2da64c0efc5293610bdd892f82a58e8cbc5d8. Не очень просто для произношения =)
Хорошая новость в том, что Git достаточно умён в работе с хешеми. Ему нужно лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто fed2 вместо колбасы выше.
Как мы уже говорили, указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки и они прекрасны!
С относительными ссылками можно начать с какого-либо удобного места (например с ветки bugFix или от HEAD) и двигаться от него
Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
    Перемещение на один коммит назад ^
    Перемещение на <num> коммитов назад ~<num>
checkout HEAD^

Оператор "~"
Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает.
checkout HEAD~<num>

2.3. Перемещение ветки (branch forcing)
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например команда:
git branch -f master HEAD~3
Переместит (принудительно) ветку master на три родителя назад от HEAD.

2.4. Отмена изменений в Git
Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк) и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.
Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert. Попробуем оба на следующем шаге.

Git Reset
git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад как будто некоторых коммитов вовсе и не было.

Git Revert
Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.
Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Посмотрим, как это работает


Поперемещаем изменения
Итак, мы уже освоили основы Git: коммиты, ветки, перемещение по дереву изменений. Уже этих знаний достаточно, чтобы овладеть 90% мощью Git-репозиториев и покрыть нужды разработчиков.
А оставшиеся 10% будут очень полезны при сложных workfow (или если ты попал в сложную ситуацию). Теперь речь пойдёт о перемещении изменений, другими словами, возможности, позволяющие разработчику сказать "Хочу, чтобы эти изменения были вот тут, а вот эти вон там" и получить точные, правильные результаты, не теряя при этом гибкости разработки.
На первый взгляд запутано, но на самом деле всё просто.

3.1. Git Cherry-pick
Первая из таких команд - это git cherry-pick`. Она выглядит вот так:
git cherry-pick <Commit1> <Commit2> <...>
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.
Посмотрим на демонстрацию.

3.2. Git Interactive Rebase
Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)
Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого -- лучший способ, чтобы отобрать набор коммитов для rebase.
Углубимся в детали.

Всё, что нужно для интерактивного rebase - это опция -i
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.

После открытия окна интерактивного rebase, есть три варианта для каждого коммита:
- Можно сменить положение коммита по порядку, просто переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть pick -- переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, если кратко -- при помощи этой функции можно объединять изменения двух коммитов.
Ну что ж, посмотрим на примеры!
rebase -i <commit_name>


4.1. Вот ситуация, которая часто случается при разработке: мы пытаемся отследить ошибку, но она не очень очевидна. Для того, чтобы достичь успеха на этом поприще, мы используем несколько команд для отладки и вывода
Каждая отладочная команда или команды вывода находится в своём коммите. В итоге, мы нашли ошибку, исправили её и порадовались!
Но проблема в том, что мы хотим добавить в master только исправление ошибки из ветки bugFix. Если мы воспользуемся простым fast-forward, то в master попадут также отладочные команды. Должен быть другой способ...

4.2. Жонглируем коммитами
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны, так что находятся друг подверх друга в репозитории.
Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:
- Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
- Внести изменения при помощи commit --amend
- Переставить всё обратно при помощи git rebase -i
- И наконец, переместить master на изменённуй часть дерева, чтобы закончить уровень.
Этот уровень можно закончить несколькими способами, но в этом уровне нужно сосредоточиться на вышеописанном методе.
Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, они каждый получать по апострофу. Ещё один апостроф добавляется, когда мы делаем commit --amend.
Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.

4.3. Жонглируем коммитами №2
Перед прохождением этого уровня обязательно надо пройти предыдущий уровен – 'Жонглиуем коммитами №1'
В прошлом уровне мы использовали rebase -i, чтобы переставлять коммиты. Как только нужный нам коммит оказывался в конце, мы могли спокойно изменить его при помощи --ammend и переставить обратно.
Единственная проблема тут - это множеств перестановок, которые могут спровоцировать конфликты. Посмотрим, как с этой же задачей справиться cherry-pick

Важно помнить, что cherry-pick поместить любой коммит сразу после HEAD (только, если этот коммит не является предком HEAD)

4.4. Теги
В прошлый уроках мы усвоили, что ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты, как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние.
В таком случае, где взять постоянную ссылку на момент в истории изменений? Для таких вещей, как релиз, большие слияния нужно нечто более постоянное, чем ветка.
Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.
Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений
Посмотрим на это на практике.

4.5. Git Describe
Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает как далеко текущее состоянии от ближайшего тега. И эта команда называется git describe
Git describe помогает сориентироваться, после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска =)

Git describe выглядить примерно так:
git describe <ref>
Где ref это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).
Вывод команды выглядит примерно так:
<tag>_<numCommits>_g<hash>
Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.


5.1. Rebase на нескольких ветках
У нас тут куча веток! Было бы круто перенести все изменения из них в мастер.
Но начальство усложняет нашу задачу тем, что желает видеть все коммиты по порядку. Так что коммит С7' должен идти после коммита С6' и так далее.
Если что-то пойдёт не так – не надо стесняться использовать reset, чтобы начать всё с чистого листа. Постарайся сделать как можно меньше манипуляций!

5.2. Определение родителей
Так же как тильда (~), каретка (^) принимает номер после себя.
Но в отличие от количества коммитов, на которые нужно откатиться назад (как делает ~), номер после ^ определяет на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать ^ нельзя.
Git по умолчанию перейдёт на "первого" родителя коммита, но указание номера после ^ изменяет это поведение.
Посмотрим как это работает.

5.3. Спутанные ветки
УОУ! В этом уровне придётся попотеть!
У нас тут по несколько коммитов в ветках one, two и three. Не важно почему, но нам надо видоизменить эти три ветки при помощи более поздних коммитов из ветки master.
Ветка one нуждается в изменении порядка и удалении C5. two тредует полного перемешивания, а three хочет получить только один коммит
Как пройти этот уровень – решать тебе, а как найдёшь решение – сравни его с нашим при помощи show solution.

